# -*- coding: utf-8 -*-
"""APEDA_data.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eB7LXlKBVM8nWa7USs7X4ZBYu34Bnqx8
"""

import time
import bs4
import pandas as pd
import os
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import Select
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import StaleElementReferenceException
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi

options = webdriver.ChromeOptions()
options.add_argument('--headless')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')

# Use options as a keyword argument when initializing webdriver.Chrome
browser = webdriver.Chrome(options=options)
browser.get("https://agriexchange.apeda.gov.in/indexp/genReport_combined.aspx")

def year_list():
  select_period = browser.find_element(By.ID, "RadioButtonList5_1")
  select_period.click()
  res = browser.page_source
  soup = bs4.BeautifulSoup(res, 'html.parser')
  year_list=[]
  for select_tag in soup.find_all('select', id='ListBoxYear'):
      for option_tag in select_tag.find_all('option'):
          year = option_tag.text.strip()  # Remove any leading or trailing whitespace
          if len(year) == 7 and year[4] == '-':  # Check if the string is in the format YYYY-YY
              year_list.append(year)
  return sorted(year_list)

def connect_db(url):
  uri = url
  # Create a new client and connect to the server
  client = MongoClient(uri, server_api=ServerApi('1'))
  client.admin.command('ping')
  table=client.india.onion_import
  return table

def submit_page(commodity,year):
  select_report_type = browser.find_element(By.ID, "RadioButtonList2_1")
  select_report_type.click()

  select_period = browser.find_element(By.ID, "RadioButtonList5_1")
  select_period.click()

  select_year = browser.find_element(By.ID, 'ListBoxYear')
  select_year1 = Select(select_year)
  try:
      WebDriverWait(browser, 10).until(
          lambda driver: len(select_year1.options) > 1
      )
  except StaleElementReferenceException:
      # If the element is stale, re-locate it and try again
      select_year = browser.find_element(By.ID, 'ListBoxYear')
      select_year1 = Select(select_year)
      WebDriverWait(browser, 10).until(
          lambda driver: len(select_year1.options) > 1
      )
  select_year1.select_by_visible_text(year)

  select_month = WebDriverWait(browser, 10).until(EC.presence_of_element_located((By.ID, 'ListBoxMonth')))
  # Wrap it in a Select object
  select_month_select = Select(select_month)
  # Create a set to keep track of selected months
  selected_months = set()
  # Press the Control key (Ctrl) and click on each option
  actions = ActionChains(browser)
  for option in select_month_select.options:
      month = option.text
      if month not in selected_months:
          # Select the option and add it to the set of selected months
          actions.key_down(Keys.CONTROL).click(option).key_up(Keys.CONTROL)
          selected_months.add(month)
  actions.perform()

  select_product = browser.find_element(By.ID, 'ListBoxProduct')
  # Wrap it in a Select object
  select_product1 = Select(select_product)
  try:
      # Wait for the options to populate (assuming options are loaded asynchronously)
      WebDriverWait(browser, 10).until(lambda driver: len(select_product1.options) > 1)
  except StaleElementReferenceException:
      # If the element is stale, re-locate it and try again
      select_product = browser.find_element(By.ID, 'ListBoxProduct')
      select_product1 = Select(select_product)
      WebDriverWait(browser, 10).until(lambda driver: len(select_product1.options) > 1)
  select_product1.select_by_visible_text(commodity)

  default_country = browser.find_element(By.ID,  "RadioButtonList4_0")
  default_country.click()

  # Find the select element for the country
  select_country = WebDriverWait(browser, 10).until(EC.presence_of_element_located((By.ID, 'ListBoxCountry')))
  # Wrap it in a Select object
  select_country_select = Select(select_country)
  try:
      # Wait for the options to populate (assuming options are loaded asynchronously)
      WebDriverWait(browser, 10).until(lambda driver: len(select_country_select.options) > 1)
  except StaleElementReferenceException:
      # If the element is stale, re-locate it and try again
      select_country = browser.find_element(By.ID, 'ListBoxCountry')
      select_country_select = Select(select_country)
      WebDriverWait(browser, 10).until(lambda driver: len(select_country_select.options) > 1)
  # Select the option by visible text
  select_country_select.select_by_visible_text("All")

  checkbox = browser.find_element(By.ID, 'Lacs')
  checkbox.click()

  Quantity = browser.find_element(By.ID, "QuantityId_2")
  Quantity.click()

  submit_button = browser.find_element(By.ID, 'Button1')
  submit_button.click()

def data_scrape():
  res = browser.page_source
  soup = bs4.BeautifulSoup(res, 'html.parser')
  return soup

def data_transform(soup,fiscal_y):
  data_list=[]
  for tab in soup.find_all('table', id='DataGrid1'):
      for t in tab.find_all('tr'):
        k=[]
        for x in t.find_all('td'):
          k.append(x.text.strip())
        data_list.append(k)
  header1=data_list[0]
  header2=data_list[1]
  header=[]
  for i in range(len(header1)):
    for x in range(i*2-1,i*2+1):
      if x>=0:
        if header1[i]=='':
          header.append(header2[x])
        else:
          hd=header1[i]+'|'+header2[x]
          header.append(hd)
  data_collect=[]
  for dc in data_list[2::]:
    data_collect.append(dc)
  df=pd.DataFrame(data_collect,columns=header)
  melted_df = pd.melt(df, id_vars=df.columns[0], var_name='Month', value_name='Value')
  melted_df[['Month', 'Measure']] = melted_df['Month'].str.split('|', expand=True)
  melted_df = melted_df.pivot_table(index=['Country', 'Month'], columns='Measure', values='Value', aggfunc='sum').reset_index()
  melted_df['Fiscal_Year']=fiscal_y
  df=melted_df
  fiscal_month_mapping = {
      'April': 4,
      'May': 5,
      'June': 6,
      'July': 7,
      'August': 8,
      'September': 9,
      'October': 10,
      'November': 11,
      'Novemmber': 11,
      'December': 12,
      'January': 1,
      'February': 2,
      'March': 3
  }
  df[['Start_Month', 'End_Month']] = df['Month'].str.split('-', expand=True)

  # Mapping fiscal months to numeric values
  df['Start_Month_Num'] = df['Start_Month'].map(fiscal_month_mapping)
  df['End_Month_Num'] = df['End_Month'].map(fiscal_month_mapping)
  df[['Start_Year', 'End_Year']] = df['Fiscal_Year'].str.split('-', expand=True)
  df['End_Year'] = '20' + df['End_Year']

  df['Calender_Year_End'] = df.apply(lambda x: x['Start_Year'] if x['End_Month_Num'] >= 4 else x['End_Year'], axis=1)
  df['Calender_Year_Start']=df['Start_Year']
  df['Start_Date_String']=df['Start_Month_Num'].astype(str)+' '+df['Calender_Year_Start']
  df['End_Date_String']=df['End_Month'].astype(str)+' '+df['Calender_Year_End']
  #date_format = "%B %Y"

  df['Start_Date'] = df.apply(lambda row: datetime(int(row['Calender_Year_Start']), int(row['Start_Month_Num']), 1), axis=1)
  df['End_Date'] = df.apply(lambda row: datetime(int(row['Calender_Year_End']), int(row['End_Month_Num']), 1), axis=1)

  #df['Start_Date'] = df['Start_Date_String'].apply(lambda x: datetime.strptime(x, date_format))
  #df['End_Date'] = df['End_Date_String'].apply(lambda x: datetime.strptime(x, date_format))
  df['End_Date'] = df['End_Date'] + pd.offsets.MonthEnd(1)
  df = df[['Country', 'Month', 'Fiscal_Year', 'Start_Date', 'End_Date', 'Qty', 'Rs. Lacs']]
  df = df.rename(columns={'Country': 'Country_Name',
                        'Month': 'Fiscal_Month',
                        'Fiscal_Year': 'Fiscal_Year',
                        'Start_Date': 'Start_Date',
                        'End_Date': 'End_Date',
                        'Qty': 'Quantity_kg',
                        'Rs. Lacs': 'Value_Rs_Lakhs'})

  return df

url=os.environ.get('MONGODB_URL_APEDA')
commodity='Fresh Onions'
table=connect_db(url)
m_date = table.find_one(sort=[('Fiscal_Year', -1)])
try:
  if m_date['Fiscal_Year'] is not None:
      min_year = m_date['Fiscal_Year']
  else:
      min_year = '2006-07'
except:
  min_year = '2006-07'

try:
  year_l=year_list()
  start_index = year_l.index(min_year)
  # Create a new list starting from the minimum year
  new_year_l = year_l[start_index:]
except:
  time.sleep(10)
  year_l=year_list()
  start_index = year_l.index(min_year)
  # Create a new list starting from the minimum year
  new_year_l = year_l[start_index:]

start_index = year_l.index(min_year)
# Create a new list starting from the minimum year
new_year_l = year_l[start_index:]
for year in new_year_l:
  browser.get("https://agriexchange.apeda.gov.in/indexp/genReport_combined.aspx")
  try:
    submit_page(commodity,year)
    soup=data_scrape()
    df=data_transform(soup,year)
  except:
    try:
      #browser.get("https://agriexchange.apeda.gov.in/indexp/genReport_combined.aspx")
      submit_page(commodity,year)
      soup=data_scrape()
      df=data_transform(soup,year)
    except:
      #browser.get("https://agriexchange.apeda.gov.in/indexp/genReport_combined.aspx")
      submit_page(commodity,year)
      soup=data_scrape()
      df=data_transform(soup,year)
  try:
    # Assuming df_clean and k are DataFrames and table is a collection from a database or similar source
    df_clean = df[['Country_Name', 'Fiscal_Month', 'Fiscal_Year', 'Start_Date', 'End_Date', 'Quantity_kg', 'Value_Rs_Lakhs']]
    k = pd.DataFrame(list(table.find()))
    k = k[['Country_Name', 'Fiscal_Month', 'Fiscal_Year', 'Start_Date', 'End_Date', 'Quantity_kg', 'Value_Rs_Lakhs']]

    # Merge df_clean and k on all columns
    merged_df = pd.merge(df_clean, k, on=['Country_Name', 'Fiscal_Month', 'Fiscal_Year', 'Start_Date', 'End_Date', 'Quantity_kg', 'Value_Rs_Lakhs'], how='outer', indicator=True)

    # Filter out rows from df_clean that are not in k
    df_to_append = merged_df[merged_df['_merge'] == 'left_only'][['Country_Name', 'Fiscal_Month', 'Fiscal_Year', 'Start_Date', 'End_Date', 'Quantity_kg', 'Value_Rs_Lakhs']]
    df_to_append['Last_Refresh_Date']=datetime.now()
  except:
    df_to_append=df
    df_to_append['Last_Refresh_Date']=datetime.now()
  data_list = df_to_append.to_dict(orient='records')
  try:
    table.insert_many(data_list)
  except:
    t=1
